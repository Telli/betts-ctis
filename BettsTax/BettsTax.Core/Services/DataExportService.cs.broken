using AutoMapper;
using BettsTax.Core.DTOs;
using BettsTax.Data;
using BettsTax.Shared;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;

namespace BettsTax.Core.Services
{
    public class DataExportService : IDataExportService
    {
        private readonly ApplicationDbContext _context;
        private readonly IMapper _mapper;
        private readonly IExportFormatService _formatService;
        private readonly IUserContextService _userContextService;
        private readonly ILogger<DataExportService> _logger;
        private readonly string _exportBasePath;

        public DataExportService(
            ApplicationDbContext context,
            IMapper mapper,
            IExportFormatService formatService,
            IUserContextService userContextService,
            ILogger<DataExportService> logger)
        {
            _context = context;
            _mapper = mapper;
            _formatService = formatService;
            _userContextService = userContextService;
            _logger = logger;
            _exportBasePath = Path.Combine(Directory.GetCurrentDirectory(), "ExportFiles");
            
            // Ensure export directory exists
            Directory.CreateDirectory(_exportBasePath);
        }

        public async Task<Result<ExportResultDto>> ExportDataAsync(ExportRequestDto request)
        {
            try
            {
                _logger.LogInformation("Starting export of type {ExportType} in format {Format}", 
                    request.ExportType, request.Format);

                // Validate request
                var validationResult = await ValidateExportRequestAsync(request);
                if (!validationResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(validationResult.ErrorMessage);

                // Create export record
                var exportId = Guid.NewGuid().ToString();
                var exportHistory = new DataExportHistory
                {
                    ExportId = exportId,
                    ExportType = request.ExportType.ToString(),
                    Format = request.Format.ToString(),
                    FileName = GenerateFileName(request),
                    Status = ExportStatus.Processing,
                    CreatedBy = _userContextService.GetCurrentUserId() ?? "System",
                    Description = request.Description,
                    IsPasswordProtected = request.PasswordProtected,
                    FiltersJson = JsonSerializer.Serialize(request),
                    ExpiryDate = DateTime.UtcNow.AddDays(30) // Default 30 days
                };

                if (request.PasswordProtected && !string.IsNullOrEmpty(request.Password))
                {
                    exportHistory.PasswordHash = HashPassword(request.Password);
                }

                _context.Set<DataExportHistory>().Add(exportHistory);
                await _context.SaveChangesAsync();

                // Route to specific export method
                var result = request.ExportType switch
                {
                    ExportType.TaxReturns => await ExportTaxReturnsAsync(request),
                    ExportType.Payments => await ExportPaymentsAsync(request),
                    ExportType.Clients => await ExportClientsAsync(request),
                    ExportType.ComplianceReport => await ExportComplianceReportAsync(request),
                    ExportType.ActivityLog => await ExportActivityLogAsync(request),
                    ExportType.Documents => await ExportDocumentsAsync(request),
                    ExportType.Penalties => await ExportPenaltiesAsync(request),
                    ExportType.Comprehensive => await ExportComprehensiveReportAsync(request),
                    _ => Result.Failure<ExportResultDto>("Unsupported export type")
                };

                if (!result.IsSuccess)
                {
                    exportHistory.Status = ExportStatus.Failed;
                    exportHistory.ErrorDetails = result.ErrorMessage;
                    await _context.SaveChangesAsync();
                    return result;
                }

                // Update export record with results
                var fileInfo = new FileInfo(result.Value.FilePath);
                exportHistory.Status = ExportStatus.Completed;
                exportHistory.CompletedDate = DateTime.UtcNow;
                exportHistory.FilePath = result.Value.FilePath;
                exportHistory.FileSizeBytes = fileInfo.Length;
                exportHistory.RecordCount = result.Value.RecordCount;

                await _context.SaveChangesAsync();

                result.Value.ExportId = exportId;
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during export of type {ExportType}", request.ExportType);
                return Result.Failure<ExportResultDto>("Export failed: " + ex.Message);
            }
        }

        public async Task<Result<ExportResultDto>> ExportTaxReturnsAsync(ExportRequestDto request)
        {
            try
            {
                var query = _context.Set<TaxFiling>()
                    .Include(t => t.Client)
                    .Include(t => t.Payments)
                    .AsQueryable();

                // Apply filters
                query = ApplyFilters(query, request);

                var taxFilings = await query.ToListAsync();

                var exportData = taxFilings.Select(t => new TaxReturnExportDto
                {
                    TaxFilingId = t.TaxFilingId,
                    ClientNumber = t.Client?.ClientNumber ?? "",
                    ClientName = t.Client?.BusinessName ?? "",
                    TIN = t.Client?.TIN ?? "",
                    TaxYear = t.TaxYear,
                    TaxType = t.TaxType.ToString(),
                    FilingStatus = t.Status.ToString(),
                    TaxLiability = t.TaxLiability,
                    TaxPaid = t.Payments?.Sum(p => p.Amount) ?? 0,
                    OutstandingBalance = t.TaxLiability - (t.Payments?.Sum(p => p.Amount) ?? 0),
                    FilingDueDate = t.DueDate ?? DateTime.UtcNow,
                    FiledDate = t.SubmittedDate,
                    PaymentDueDate = t.DueDate ?? DateTime.UtcNow,
                    PaidDate = t.Payments?.OrderByDescending(p => p.PaymentDate).FirstOrDefault()?.PaymentDate,
                    Notes = t.ReviewComments ?? "",
                    CreatedDate = t.CreatedDate,
                    LastUpdated = t.UpdatedDate,
                    TaxpayerCategory = t.Client?.TaxpayerCategory.ToString() ?? "",
                    ClientEmail = t.Client?.Email ?? "",
                    ClientPhone = t.Client?.PhoneNumber ?? "",
                    HasPenalties = false, // TODO: Add penalty check
                    TotalPenalties = 0, // TODO: Calculate penalties
                    DaysOverdue = t.SubmittedDate.HasValue ? 0 : Math.Max(0, (DateTime.UtcNow - (t.DueDate ?? DateTime.UtcNow)).Days),
                    ComplianceStatus = "Compliant" // TODO: Add compliance status
                }).ToList();

                var filePath = Path.Combine(_exportBasePath, GenerateFileName(request));
                
                var formatResult = request.Format switch
                {
                    ExportFormat.Excel => await _formatService.ExportToExcelAsync(exportData, filePath, "Tax Returns"),
                    ExportFormat.CSV => await _formatService.ExportToCsvAsync(exportData, filePath),
                    ExportFormat.PDF => await _formatService.ExportToPdfAsync(exportData, filePath, "Tax Returns Report", request),
                    ExportFormat.JSON => await _formatService.ExportToJsonAsync(exportData, filePath),
                    ExportFormat.XML => await _formatService.ExportToXmlAsync(exportData, filePath, "TaxReturns"),
                    _ => Result.Failure<string>("Unsupported format")
                };

                if (!formatResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(formatResult.ErrorMessage);

                // Apply password protection if requested
                if (request.PasswordProtected && !string.IsNullOrEmpty(request.Password))
                {
                    var protectedResult = await _formatService.PasswordProtectFileAsync(filePath, request.Password, request.Format);
                    if (protectedResult.IsSuccess)
                        filePath = protectedResult.Value;
                }

                return Result.Success(new ExportResultDto
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    Format = request.Format,
                    ExportType = request.ExportType,
                    RecordCount = exportData.Count,
                    CreatedDate = DateTime.UtcNow,
                    Status = "Completed",
                    IsPasswordProtected = request.PasswordProtected,
                    Description = request.Description,
                    Metadata = new ExportMetadataDto
                    {
                        GeneratedDate = DateTime.UtcNow,
                        GeneratedBy = _userContextService.GetCurrentUserId() ?? "System",
                        TotalRecords = exportData.Count,
                        DataStartDate = request.StartDate,
                        DataEndDate = request.EndDate,
                        IncludedFields = typeof(TaxReturnExportDto).GetProperties().Select(p => p.Name).ToList(),
                        Filters = JsonSerializer.Deserialize<Dictionary<string, object>>(JsonSerializer.Serialize(request)) ?? new(),
                        IncludedTables = new List<string> { "TaxFilings", "Clients", "TaxYears", "Payments" },
                        SystemVersion = "1.0",
                        ExportVersion = "1.0"
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting tax returns");
                return Result.Failure<ExportResultDto>("Failed to export tax returns: " + ex.Message);
            }
        }

        public async Task<Result<ExportResultDto>> ExportPaymentsAsync(ExportRequestDto request)
        {
            try
            {
                var query = _context.Set<Payment>()
                    .Include(p => p.Client)
                    .Include(p => p.TaxFiling)
                    .AsQueryable();

                // Apply date filters
                if (request.StartDate.HasValue)
                    query = query.Where(p => p.PaymentDate >= request.StartDate.Value);
                if (request.EndDate.HasValue)
                    query = query.Where(p => p.PaymentDate <= request.EndDate.Value);

                // Apply client filters
                if (request.ClientIds.Any())
                    query = query.Where(p => request.ClientIds.Contains(p.ClientId));

                // Apply status filters
                if (request.PaymentStatus.HasValue)
                    query = query.Where(p => p.Status == request.PaymentStatus.Value);

                var payments = await query.ToListAsync();

                var exportData = payments.Select(p => new PaymentExportDto
                {
                    PaymentId = p.PaymentId,
                    ClientNumber = p.Client?.ClientNumber ?? "",
                    ClientName = p.Client?.BusinessName ?? "",
                    TIN = p.Client?.TIN ?? "",
                    TaxYear = p.TaxYearId ?? 0,
                    TaxType = p.TaxFiling?.TaxType.ToString() ?? "",
                    Amount = p.Amount,
                    PaymentMethod = p.Method.ToString(),
                    PaymentStatus = p.Status.ToString(),
                    PaymentDate = p.PaymentDate,
                    TransactionId = p.PaymentReference,
                    ReceiptNumber = p.PaymentReference,
                    Notes = p.RejectionReason ?? "",
                    CreatedDate = p.CreatedAt,
                    PaymentProvider = "", // TODO: Add provider tracking
                    Fee = null, // TODO: Add fee tracking
                    Currency = "SLE",
                    IsReconciled = p.Status == PaymentStatus.Approved,
                    ReconciliationDate = p.Status == PaymentStatus.Approved ? p.ApprovedAt : null
                }).ToList();

                var filePath = Path.Combine(_exportBasePath, GenerateFileName(request));
                
                var formatResult = request.Format switch
                {
                    ExportFormat.Excel => await _formatService.ExportToExcelAsync(exportData, filePath, "Payments"),
                    ExportFormat.CSV => await _formatService.ExportToCsvAsync(exportData, filePath),
                    ExportFormat.PDF => await _formatService.ExportToPdfAsync(exportData, filePath, "Payments Report", request),
                    ExportFormat.JSON => await _formatService.ExportToJsonAsync(exportData, filePath),
                    ExportFormat.XML => await _formatService.ExportToXmlAsync(exportData, filePath, "Payments"),
                    _ => Result.Failure<string>("Unsupported format")
                };

                if (!formatResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(formatResult.ErrorMessage);

                // Apply password protection if requested
                if (request.PasswordProtected && !string.IsNullOrEmpty(request.Password))
                {
                    var protectedResult = await _formatService.PasswordProtectFileAsync(filePath, request.Password, request.Format);
                    if (protectedResult.IsSuccess)
                        filePath = protectedResult.Value;
                }

                return Result.Success(new ExportResultDto
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    Format = request.Format,
                    ExportType = request.ExportType,
                    RecordCount = exportData.Count,
                    CreatedDate = DateTime.UtcNow,
                    Status = "Completed",
                    IsPasswordProtected = request.PasswordProtected,
                    Description = request.Description
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting payments");
                return Result.Failure<ExportResultDto>("Failed to export payments: " + ex.Message);
            }
        }

        public async Task<Result<ExportResultDto>> ExportClientsAsync(ExportRequestDto request)
        {
            try
            {
                var query = _context.Set<Client>()
                    .Include(c => c.User)
                    .AsQueryable();

                // Apply client filters
                if (request.ClientIds.Any())
                    query = query.Where(c => request.ClientIds.Contains(c.ClientId));

                // Apply date filters on creation date
                if (request.StartDate.HasValue)
                    query = query.Where(c => c.CreatedDate >= request.StartDate.Value);
                if (request.EndDate.HasValue)
                    query = query.Where(c => c.CreatedDate <= request.EndDate.Value);

                var clients = await query.ToListAsync();

                var exportData = clients.Select(c => new ClientExportDto
                {
                    ClientId = c.ClientId,
                    ClientNumber = c.ClientNumber,
                    BusinessName = c.BusinessName,
                    ContactPerson = c.ContactPerson,
                    Email = c.Email,
                    PhoneNumber = c.PhoneNumber,
                    TIN = c.TIN,
                    TaxpayerCategory = c.TaxpayerCategory.ToString(),
                    BusinessType = c.ClientType.ToString(),
                    Address = c.Address ?? "",
                    City = "", // TODO: Extract from address
                    Country = "Sierra Leone",
                    RegistrationDate = c.CreatedDate,
                    ClientStatus = c.Status.ToString(),
                    IsActive = c.Status == ClientStatus.Active,
                    LastLoginDate = c.CreatedDate, // TODO: Track last login
                    CreatedDate = c.CreatedDate,
                    TotalTaxFilings = 0, // TODO: Add TaxFilings navigation
                    TotalTaxPaid = 0, // TODO: Calculate from payments
                    OutstandingBalance = 0, // TODO: Calculate from TaxFilings and payments
                    ComplianceStatus = "Compliant", // TODO: Calculate from compliance tracker
                    ComplianceScore = 100m, // TODO: Calculate from compliance tracker
                    UnresolvedAlerts = 0, // TODO: Calculate from compliance alerts
                    PendingActions = 0 // TODO: Calculate from compliance actions
                }).ToList();

                var filePath = Path.Combine(_exportBasePath, GenerateFileName(request));
                
                var formatResult = request.Format switch
                {
                    ExportFormat.Excel => await _formatService.ExportToExcelAsync(exportData, filePath, "Clients"),
                    ExportFormat.CSV => await _formatService.ExportToCsvAsync(exportData, filePath),
                    ExportFormat.PDF => await _formatService.ExportToPdfAsync(exportData, filePath, "Clients Report", request),
                    ExportFormat.JSON => await _formatService.ExportToJsonAsync(exportData, filePath),
                    ExportFormat.XML => await _formatService.ExportToXmlAsync(exportData, filePath, "Clients"),
                    _ => Result.Failure<string>("Unsupported format")
                };

                if (!formatResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(formatResult.ErrorMessage);

                return Result.Success(new ExportResultDto
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    Format = request.Format,
                    ExportType = request.ExportType,
                    RecordCount = exportData.Count,
                    CreatedDate = DateTime.UtcNow,
                    Status = "Completed",
                    IsPasswordProtected = request.PasswordProtected,
                    Description = request.Description
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting clients");
                return Result.Failure<ExportResultDto>("Failed to export clients: " + ex.Message);
            }
        }

        public async Task<Result<ExportResultDto>> ExportComplianceReportAsync(ExportRequestDto request)
        {
            try
            {
                var query = _context.Set<ComplianceTracker>()
                    .Include(c => c.Client)
                    .Include(c => c.Penalties)
                    .Include(c => c.Alerts.Where(a => a.IsActive))
                    .Include(c => c.Actions.Where(a => !a.IsCompleted))
                    .AsQueryable();

                // Apply filters
                if (request.ClientIds.Any())
                    query = query.Where(c => request.ClientIds.Contains(c.ClientId));

                if (request.TaxYearIds.Any())
                    query = query.Where(c => request.TaxYearIds.Contains(c.TaxYearId));

                if (request.TaxTypes.Any())
                    query = query.Where(c => request.TaxTypes.Contains(c.TaxType));

                if (request.ComplianceStatus.HasValue)
                    query = query.Where(c => c.Status == request.ComplianceStatus.Value);

                var complianceData = await query.ToListAsync();

                var exportData = complianceData.Select(c => new ComplianceReportExportDto
                {
                    ClientNumber = c.Client?.ClientNumber ?? "",
                    ClientName = c.Client?.BusinessName ?? "",
                    TIN = c.Client?.TIN ?? "",
                    TaxYear = c.TaxYearId,
                    TaxType = c.TaxType.ToString(),
                    ComplianceStatus = c.Status.ToString(),
                    RiskLevel = c.RiskLevel.ToString(),
                    ComplianceScore = c.ComplianceScore,
                    IsFilingRequired = c.IsFilingRequired,
                    IsPaymentRequired = c.IsPaymentRequired,
                    IsFilingComplete = c.IsFilingComplete,
                    IsPaymentComplete = c.IsPaymentComplete,
                    IsDocumentationComplete = c.IsDocumentationComplete,
                    FilingDueDate = c.FilingDueDate,
                    PaymentDueDate = c.PaymentDueDate,
                    FiledDate = c.FiledDate,
                    PaidDate = c.PaidDate,
                    DaysOverdueForFiling = c.DaysOverdueForFiling,
                    DaysOverdueForPayment = c.DaysOverdueForPayment,
                    TaxLiability = c.TaxLiability,
                    AmountPaid = c.AmountPaid,
                    OutstandingBalance = c.OutstandingBalance,
                    TotalPenaltiesOwed = c.TotalPenaltiesOwed,
                    TotalPenaltiesPaid = c.TotalPenaltiesPaid,
                    OutstandingPenalties = c.OutstandingPenalties,
                    ActiveAlertsCount = c.Alerts?.Count ?? 0,
                    CriticalAlertsCount = c.Alerts?.Count(a => a.Severity == ComplianceAlertSeverity.Critical || a.Severity == ComplianceAlertSeverity.Urgent) ?? 0,
                    PendingActionsCount = c.Actions?.Count ?? 0,
                    OverdueActionsCount = c.Actions?.Count(a => a.IsOverdue) ?? 0,
                    LastUpdated = c.LastUpdated
                }).ToList();

                var filePath = Path.Combine(_exportBasePath, GenerateFileName(request));
                
                var formatResult = request.Format switch
                {
                    ExportFormat.Excel => await _formatService.ExportToExcelAsync(exportData, filePath, "Compliance Report"),
                    ExportFormat.CSV => await _formatService.ExportToCsvAsync(exportData, filePath),
                    ExportFormat.PDF => await _formatService.ExportToPdfAsync(exportData, filePath, "Compliance Report", request),
                    ExportFormat.JSON => await _formatService.ExportToJsonAsync(exportData, filePath),
                    ExportFormat.XML => await _formatService.ExportToXmlAsync(exportData, filePath, "ComplianceReport"),
                    _ => Result.Failure<string>("Unsupported format")
                };

                if (!formatResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(formatResult.ErrorMessage);

                return Result.Success(new ExportResultDto
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    Format = request.Format,
                    ExportType = request.ExportType,
                    RecordCount = exportData.Count,
                    CreatedDate = DateTime.UtcNow,
                    Status = "Completed",
                    IsPasswordProtected = request.PasswordProtected,
                    Description = request.Description
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting compliance report");
                return Result.Failure<ExportResultDto>("Failed to export compliance report: " + ex.Message);
            }
        }

        public async Task<Result<ExportResultDto>> ExportActivityLogAsync(ExportRequestDto request)
        {
            try
            {
                var query = _context.Set<ActivityTimeline>()
                    .Include(a => a.Client)
                    .Include(a => a.User)
                    .Include(a => a.Document)
                    .Include(a => a.TaxFiling)
                    .Include(a => a.Payment)
                    .AsQueryable();

                // Apply filters
                if (request.ClientIds.Any())
                    query = query.Where(a => a.ClientId.HasValue && request.ClientIds.Contains(a.ClientId.Value));

                if (request.StartDate.HasValue)
                    query = query.Where(a => a.ActivityDate >= request.StartDate.Value);
                if (request.EndDate.HasValue)
                    query = query.Where(a => a.ActivityDate <= request.EndDate.Value);

                var activities = await query.OrderByDescending(a => a.ActivityDate).ToListAsync();

                var exportData = activities.Select(a => new ActivityLogExportDto
                {
                    ActivityId = a.ActivityTimelineId,
                    ClientNumber = a.Client?.ClientNumber ?? "",
                    ClientName = a.Client?.BusinessName ?? "",
                    ActivityDate = a.ActivityDate,
                    ActivityType = a.ActivityType.ToString(),
                    Title = a.Title,
                    Description = a.Description,
                    PerformedBy = a.User?.UserName ?? "",
                    PerformedByRole = "User", // Default role, could be enhanced with actual role lookup
                    RelatedEntity = GetRelatedEntityName(a),
                    RelatedEntityId = GetRelatedEntityId(a),
                    Metadata = a.Metadata ?? "",
                    IpAddress = a.IpAddress ?? "",
                    UserAgent = a.UserAgent ?? ""
                }).ToList();

                var filePath = Path.Combine(_exportBasePath, GenerateFileName(request));
                
                var formatResult = request.Format switch
                {
                    ExportFormat.Excel => await _formatService.ExportToExcelAsync(exportData, filePath, "Activity Log"),
                    ExportFormat.CSV => await _formatService.ExportToCsvAsync(exportData, filePath),
                    ExportFormat.PDF => await _formatService.ExportToPdfAsync(exportData, filePath, "Activity Log Report", request),
                    ExportFormat.JSON => await _formatService.ExportToJsonAsync(exportData, filePath),
                    ExportFormat.XML => await _formatService.ExportToXmlAsync(exportData, filePath, "ActivityLog"),
                    _ => Result.Failure<string>("Unsupported format")
                };

                if (!formatResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(formatResult.ErrorMessage);

                return Result.Success(new ExportResultDto
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    Format = request.Format,
                    ExportType = request.ExportType,
                    RecordCount = exportData.Count,
                    CreatedDate = DateTime.UtcNow,
                    Status = "Completed",
                    IsPasswordProtected = request.PasswordProtected,
                    Description = request.Description
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting activity log");
                return Result.Failure<ExportResultDto>("Failed to export activity log: " + ex.Message);
            }
        }

        public async Task<Result<ExportResultDto>> ExportDocumentsAsync(ExportRequestDto request)
        {
            try
            {
                var query = _context.Set<Document>()
                    .Include(d => d.TaxFiling)
                    .ThenInclude(t => t.Client)
                    .Include(d => d.UploadedBy)
                    .Include(d => d.DocumentVerification)
                    .AsQueryable();

                // Apply filters
                if (request.ClientIds.Any())
                    query = query.Where(d => d.TaxFiling != null && request.ClientIds.Contains(d.TaxFiling.ClientId));

                if (request.StartDate.HasValue)
                    query = query.Where(d => d.UploadedAt >= request.StartDate.Value);
                if (request.EndDate.HasValue)
                    query = query.Where(d => d.UploadedAt <= request.EndDate.Value);

                var documents = await query.OrderByDescending(d => d.UploadedAt).ToListAsync();

                var exportData = documents.Select(d => new DocumentExportDto
                {
                    DocumentId = d.DocumentId,
                    ClientNumber = d.TaxFiling?.Client?.ClientNumber ?? "",
                    ClientName = d.TaxFiling?.Client?.BusinessName ?? "",
                    DocumentName = d.Description,
                    DocumentType = d.Category.ToString(),
                    FileName = d.OriginalFileName,
                    FileSize = d.Size,
                    MimeType = d.ContentType,
                    UploadDate = d.UploadedAt,
                    Status = "Uploaded", // Default status, could be enhanced
                    IsVerified = d.DocumentVerification != null,
                    VerifiedDate = d.DocumentVerification?.ReviewedDate,
                    VerifiedBy = d.DocumentVerification?.ReviewedBy?.Email ?? "",
                    Notes = d.DocumentVerification?.ReviewNotes ?? "",
                    TaxYear = d.TaxYear?.Year,
                    TaxType = d.TaxFiling?.TaxType.ToString(),
                    FilePath = d.StoragePath,
                    IsRequired = true, // TODO: Determine from document requirements
                    RequiredByDate = null // TODO: Add from requirements
                }).ToList();

                var filePath = Path.Combine(_exportBasePath, GenerateFileName(request));
                
                var formatResult = request.Format switch
                {
                    ExportFormat.Excel => await _formatService.ExportToExcelAsync(exportData, filePath, "Documents"),
                    ExportFormat.CSV => await _formatService.ExportToCsvAsync(exportData, filePath),
                    ExportFormat.PDF => await _formatService.ExportToPdfAsync(exportData, filePath, "Documents Report", request),
                    ExportFormat.JSON => await _formatService.ExportToJsonAsync(exportData, filePath),
                    ExportFormat.XML => await _formatService.ExportToXmlAsync(exportData, filePath, "Documents"),
                    _ => Result.Failure<string>("Unsupported format")
                };

                if (!formatResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(formatResult.ErrorMessage);

                return Result.Success(new ExportResultDto
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    Format = request.Format,
                    ExportType = request.ExportType,
                    RecordCount = exportData.Count,
                    CreatedDate = DateTime.UtcNow,
                    Status = "Completed",
                    IsPasswordProtected = request.PasswordProtected,
                    Description = request.Description
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting documents");
                return Result.Failure<ExportResultDto>("Failed to export documents: " + ex.Message);
            }
        }

        public async Task<Result<ExportResultDto>> ExportPenaltiesAsync(ExportRequestDto request)
        {
            try
            {
                var query = _context.Set<CompliancePenalty>()
                    .Include(p => p.ComplianceTracker)
                    .ThenInclude(c => c.Client)
                    .AsQueryable();

                // Apply filters
                if (request.ClientIds.Any())
                    query = query.Where(p => p.ComplianceTracker != null && request.ClientIds.Contains(p.ComplianceTracker.ClientId));

                if (request.StartDate.HasValue)
                    query = query.Where(p => p.PenaltyDate >= request.StartDate.Value);
                if (request.EndDate.HasValue)
                    query = query.Where(p => p.PenaltyDate <= request.EndDate.Value);

                if (request.TaxTypes.Any())
                    query = query.Where(p => p.ComplianceTracker != null && request.TaxTypes.Contains(p.ComplianceTracker.TaxType));

                var penalties = await query.OrderByDescending(p => p.PenaltyDate).ToListAsync();

                var exportData = penalties.Select(p => new PenaltyExportDto
                {
                    PenaltyId = p.CompliancePenaltyId,
                    ClientNumber = p.ComplianceTracker?.Client?.ClientNumber ?? "",
                    ClientName = p.ComplianceTracker?.Client?.BusinessName ?? "",
                    TIN = p.ComplianceTracker?.Client?.TIN ?? "",
                    TaxYear = p.ComplianceTracker?.TaxYearId ?? 0,
                    TaxType = p.ComplianceTracker?.TaxType.ToString() ?? "",
                    PenaltyType = p.PenaltyType.ToString(),
                    Description = p.Description,
                    Amount = p.Amount,
                    AmountPaid = p.AmountPaid,
                    OutstandingAmount = p.OutstandingAmount,
                    PenaltyRate = p.PenaltyRate,
                    BaseAmount = p.BaseAmount,
                    DaysOverdue = p.DaysOverdue,
                    IsPaid = p.IsPaid,
                    IsWaived = p.IsWaived,
                    WaiverReason = p.WaiverReason,
                    PenaltyDate = p.PenaltyDate,
                    DueDate = p.DueDate,
                    PaidDate = p.PaidDate,
                    WaivedDate = p.WaivedDate,
                    CalculationDetails = p.CalculationDetails ?? "",
                    LegalReference = "" // TODO: Add legal reference from penalty rules
                }).ToList();

                var filePath = Path.Combine(_exportBasePath, GenerateFileName(request));
                
                var formatResult = request.Format switch
                {
                    ExportFormat.Excel => await _formatService.ExportToExcelAsync(exportData, filePath, "Penalties"),
                    ExportFormat.CSV => await _formatService.ExportToCsvAsync(exportData, filePath),
                    ExportFormat.PDF => await _formatService.ExportToPdfAsync(exportData, filePath, "Penalties Report", request),
                    ExportFormat.JSON => await _formatService.ExportToJsonAsync(exportData, filePath),
                    ExportFormat.XML => await _formatService.ExportToXmlAsync(exportData, filePath, "Penalties"),
                    _ => Result.Failure<string>("Unsupported format")
                };

                if (!formatResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(formatResult.ErrorMessage);

                return Result.Success(new ExportResultDto
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    Format = request.Format,
                    ExportType = request.ExportType,
                    RecordCount = exportData.Count,
                    CreatedDate = DateTime.UtcNow,
                    Status = "Completed",
                    IsPasswordProtected = request.PasswordProtected,
                    Description = request.Description
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting penalties");
                return Result.Failure<ExportResultDto>("Failed to export penalties: " + ex.Message);
            }
        }

        public async Task<Result<ExportResultDto>> ExportComprehensiveReportAsync(ExportRequestDto request)
        {
            try
            {
                _logger.LogInformation("Starting comprehensive export with filters: {Filters}", JsonSerializer.Serialize(request));

                // Get all data types
                var taxReturnsResult = await ExportTaxReturnsAsync(request);
                var paymentsResult = await ExportPaymentsAsync(request);
                var clientsResult = await ExportClientsAsync(request);
                var complianceResult = await ExportComplianceReportAsync(request);

                // Check if all exports succeeded
                if (!taxReturnsResult.IsSuccess || !paymentsResult.IsSuccess || 
                    !clientsResult.IsSuccess || !complianceResult.IsSuccess)
                {
                    var errors = new List<string>();
                    if (!taxReturnsResult.IsSuccess) errors.Add($"Tax Returns: {taxReturnsResult.ErrorMessage}");
                    if (!paymentsResult.IsSuccess) errors.Add($"Payments: {paymentsResult.ErrorMessage}");
                    if (!clientsResult.IsSuccess) errors.Add($"Clients: {clientsResult.ErrorMessage}");
                    if (!complianceResult.IsSuccess) errors.Add($"Compliance: {complianceResult.ErrorMessage}");
                    
                    return Result.Failure<ExportResultDto>($"Some exports failed: {string.Join("; ", errors)}");
                }

                // Create comprehensive data structure
                var comprehensiveData = new ComprehensiveExportData
                {
                    TaxReturns = new List<TaxReturnExportDto>(), // Populated from individual exports
                    Payments = new List<PaymentExportDto>(),
                    Clients = new List<ClientExportDto>(),
                    ComplianceReports = new List<ComplianceReportExportDto>()
                };

                var filePath = Path.Combine(_exportBasePath, GenerateFileName(request));

                Result<string> formatResult;

                if (request.Format == ExportFormat.Excel)
                {
                    // For Excel, create multi-sheet workbook
                    var sheets = new Dictionary<string, object>
                    {
                        ["TaxReturns"] = comprehensiveData.TaxReturns,
                        ["Payments"] = comprehensiveData.Payments,
                        ["Clients"] = comprehensiveData.Clients,
                        ["Compliance"] = comprehensiveData.ComplianceReports
                    };
                    formatResult = await _formatService.ExportMultiSheetExcelAsync(sheets, filePath);
                }
                else if (request.Format == ExportFormat.PDF)
                {
                    formatResult = await _formatService.ExportComprehensivePdfAsync(comprehensiveData, filePath, request);
                }
                else
                {
                    // For other formats, create a summary report
                    var summaryData = new
                    {
                        ExportSummary = new
                        {
                            TotalRecords = comprehensiveData.TaxReturns.Count + comprehensiveData.Payments.Count + 
                                         comprehensiveData.Clients.Count + comprehensiveData.ComplianceReports.Count,
                            TaxReturnsCount = comprehensiveData.TaxReturns.Count,
                            PaymentsCount = comprehensiveData.Payments.Count,
                            ClientsCount = comprehensiveData.Clients.Count,
                            ComplianceReportsCount = comprehensiveData.ComplianceReports.Count,
                            ExportDate = DateTime.UtcNow,
                            FilterApplied = !string.IsNullOrEmpty(request.Description) ? request.Description : "Standard filters applied"
                        },
                        DetailedData = comprehensiveData
                    };

                    formatResult = request.Format switch
                    {
                        ExportFormat.CSV => await _formatService.ExportToCsvAsync(new[] { summaryData }, filePath),
                        ExportFormat.JSON => await _formatService.ExportToJsonAsync(new[] { comprehensiveData }, filePath),
                        ExportFormat.XML => await _formatService.ExportToXmlAsync(new[] { comprehensiveData }, filePath, "ComprehensiveReport"),
                        _ => Result.Failure<string>("Unsupported format for comprehensive export")
                    };
                }

                if (!formatResult.IsSuccess)
                    return Result.Failure<ExportResultDto>(formatResult.ErrorMessage);

                var totalRecords = comprehensiveData.TaxReturns.Count + comprehensiveData.Payments.Count + 
                                 comprehensiveData.Clients.Count + comprehensiveData.ComplianceReports.Count;

                return Result.Success(new ExportResultDto
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    Format = request.Format,
                    ExportType = request.ExportType,
                    RecordCount = totalRecords,
                    CreatedDate = DateTime.UtcNow,
                    Status = "Completed",
                    IsPasswordProtected = request.PasswordProtected,
                    Description = request.Description ?? "Comprehensive export of all tax data",
                    Metadata = new ExportMetadataDto
                    {
                        GeneratedDate = DateTime.UtcNow,
                        GeneratedBy = _userContextService.GetCurrentUserId() ?? "System",
                        TotalRecords = totalRecords,
                        DataStartDate = request.StartDate,
                        DataEndDate = request.EndDate,
                        IncludedFields = new List<string> { "TaxReturns", "Payments", "Clients", "ComplianceReports" },
                        Filters = JsonSerializer.Deserialize<Dictionary<string, object>>(JsonSerializer.Serialize(request)) ?? new(),
                        IncludedTables = new List<string> { "TaxFilings", "Payments", "Clients", "ComplianceTrackers", "CompliancePenalties" },
                        SystemVersion = "1.0",
                        ExportVersion = "1.0"
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting comprehensive report");
                return Result.Failure<ExportResultDto>("Failed to export comprehensive report: " + ex.Message);
            }
        }

        public async Task<Result<BulkExportResultDto>> BulkExportAsync(BulkExportRequestDto request)
        {
            // TODO: Implement bulk export
            return Result.Failure<BulkExportResultDto>("Bulk export not yet implemented");
        }

        // Placeholder implementations for other interface methods
        public async Task<Result<List<ExportHistoryDto>>> GetExportHistoryAsync(string? userId = null, DateTime? fromDate = null, DateTime? toDate = null)
        {
            return Result.Success(new List<ExportHistoryDto>());
        }

        public async Task<Result<ExportResultDto>> GetExportByIdAsync(string exportId)
        {
            return Result.Failure<ExportResultDto>("Not implemented");
        }

        public async Task<Result<bool>> DeleteExportAsync(string exportId)
        {
            return Result.Success(true);
        }

        public async Task<Result<Stream>> DownloadExportAsync(string exportId, string? password = null)
        {
            return Result.Failure<Stream>("Not implemented");
        }

        public async Task<Result<bool>> ExtendExportExpiryAsync(string exportId, DateTime newExpiryDate)
        {
            return Result.Success(true);
        }

        public async Task<Result<List<ExportTemplateDto>>> GetExportTemplatesAsync()
        {
            return Result.Success(new List<ExportTemplateDto>());
        }

        public async Task<Result<ExportTemplateDto>> CreateExportTemplateAsync(CreateExportTemplateDto template)
        {
            return Result.Failure<ExportTemplateDto>("Not implemented");
        }

        public async Task<Result<ExportResultDto>> RunExportTemplateAsync(int templateId, DateTime? customStartDate = null, DateTime? customEndDate = null)
        {
            return Result.Failure<ExportResultDto>("Not implemented");
        }

        public async Task<Result<ExportPreviewDto>> PreviewExportAsync(ExportRequestDto request)
        {
            return Result.Success(new ExportPreviewDto());
        }

        public async Task<Result<bool>> ValidateExportRequestAsync(ExportRequestDto request)
        {
            if (request.StartDate.HasValue && request.EndDate.HasValue && request.StartDate > request.EndDate)
                return Result.Failure<bool>("Start date cannot be after end date");

            return Result.Success(true);
        }

        public async Task<Result<int>> CleanupExpiredExportsAsync()
        {
            return Result.Success(0);
        }

        public async Task<Result<ExportStatisticsDto>> GetExportStatisticsAsync(DateTime? fromDate = null, DateTime? toDate = null)
        {
            return Result.Success(new ExportStatisticsDto());
        }

        // Helper methods
        private IQueryable<TaxFiling> ApplyFilters(IQueryable<TaxFiling> query, ExportRequestDto request)
        {
            if (request.StartDate.HasValue)
                query = query.Where(t => t.CreatedDate >= request.StartDate.Value);
            if (request.EndDate.HasValue)
                query = query.Where(t => t.CreatedDate <= request.EndDate.Value);

            if (request.ClientIds.Any())
                query = query.Where(t => request.ClientIds.Contains(t.ClientId));

            if (request.TaxYearIds.Any())
                query = query.Where(t => request.TaxYearIds.Contains(t.TaxYear));

            if (request.TaxTypes.Any())
                query = query.Where(t => request.TaxTypes.Contains(t.TaxType));

            if (request.FilingStatus.HasValue)
                query = query.Where(t => t.Status == request.FilingStatus.Value);

            return query;
        }

        private string GenerateFileName(ExportRequestDto request)
        {
            var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
            var extension = request.Format.ToString().ToLower();
            var fileName = request.FileName ?? $"{request.ExportType}_{timestamp}";
            
            return $"{fileName}.{extension}";
        }

        private string HashPassword(string password)
        {
            using var sha256 = SHA256.Create();
            var hashedBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));
            return Convert.ToBase64String(hashedBytes);
        }

        private string GetRelatedEntityName(ActivityTimeline activity)
        {
            if (activity.DocumentId.HasValue) return "Document";
            if (activity.TaxFilingId.HasValue) return "TaxFiling";
            if (activity.PaymentId.HasValue) return "Payment";
    }
});
}
catch (Exception ex)
{
    _logger.LogError(ex, "Error exporting comprehensive report");
    return Result.Failure<ExportResultDto>("Failed to export comprehensive report: " + ex.Message);
}

public async Task<Result<BulkExportResultDto>> BulkExportAsync(BulkExportRequestDto request)
{
    // TODO: Implement bulk export
    return Result.Failure<BulkExportResultDto>("Bulk export not yet implemented");
}

// Placeholder implementations for other interface methods
public async Task<Result<List<ExportHistoryDto>>> GetExportHistoryAsync(string? userId = null, DateTime? fromDate = null, DateTime? toDate = null)
{
    return Result.Success(new List<ExportHistoryDto>());
}

public async Task<Result<ExportResultDto>> GetExportByIdAsync(string exportId)
{
    return Result.Failure<ExportResultDto>("Not implemented");
}

public async Task<Result<bool>> DeleteExportAsync(string exportId)
{
    return Result.Success(true);
}

public async Task<Result<Stream>> DownloadExportAsync(string exportId, string? password = null)
{
    return Result.Failure<Stream>("Not implemented");
}

public async Task<Result<bool>> ExtendExportExpiryAsync(string exportId, DateTime newExpiryDate)
{
    return Result.Success(true);
}

public async Task<Result<List<ExportTemplateDto>>> GetExportTemplatesAsync()
{
    return Result.Success(new List<ExportTemplateDto>());
}

public async Task<Result<ExportTemplateDto>> CreateExportTemplateAsync(CreateExportTemplateDto template)
{
    return Result.Failure<ExportTemplateDto>("Not implemented");
}

public async Task<Result<ExportResultDto>> RunExportTemplateAsync(int templateId, DateTime? customStartDate = null, DateTime? customEndDate = null)
{
    return Result.Failure<ExportResultDto>("Not implemented");
}

public async Task<Result<ExportPreviewDto>> PreviewExportAsync(ExportRequestDto request)
{
    return Result.Success(new ExportPreviewDto());
}

public async Task<Result<bool>> ValidateExportRequestAsync(ExportRequestDto request)
{
    if (request.StartDate.HasValue && request.EndDate.HasValue && request.StartDate > request.EndDate)
        return Result.Failure<bool>("Start date cannot be after end date");

    return Result.Success(true);
}

public async Task<Result<int>> CleanupExpiredExportsAsync()
{
    return Result.Success(0);
}

public async Task<Result<ExportStatisticsDto>> GetExportStatisticsAsync(DateTime? fromDate = null, DateTime? toDate = null)
{
    return Result.Success(new ExportStatisticsDto());
}

// Helper methods
private IQueryable<TaxFiling> ApplyFilters(IQueryable<TaxFiling> query, ExportRequestDto request)
{
    if (request.StartDate.HasValue)
        query = query.Where(t => t.CreatedDate >= request.StartDate.Value);
    if (request.EndDate.HasValue)
        query = query.Where(t => t.CreatedDate <= request.EndDate.Value);

    if (request.ClientIds.Any())
        query = query.Where(t => request.ClientIds.Contains(t.ClientId));

    if (request.TaxYearIds.Any())
        query = query.Where(t => request.TaxYearIds.Contains(t.TaxYear));

    if (request.TaxTypes.Any())
        query = query.Where(t => request.TaxTypes.Contains(t.TaxType));

    if (request.FilingStatus.HasValue)
        query = query.Where(t => t.Status == request.FilingStatus.Value);

    return query;
}

private string GenerateFileName(ExportRequestDto request)
{
    var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
    var extension = request.Format.ToString().ToLower();
    var fileName = request.FileName ?? $"{request.ExportType}_{timestamp}";
    
    return $"{fileName}.{extension}";
}

private string HashPassword(string password)
{
    using var sha256 = SHA256.Create();
    var hashedBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));
    return Convert.ToBase64String(hashedBytes);
}

private string GetRelatedEntityName(ActivityTimeline activity)
{
    if (activity.DocumentId.HasValue) return "Document";
    if (activity.TaxFilingId.HasValue) return "TaxFiling";
    if (activity.PaymentId.HasValue) return "Payment";
    if (activity.MessageId.HasValue) return "Message";
    if (activity.ClientId.HasValue) return "Client";
    return "";
}

private int? GetRelatedEntityId(ActivityTimeline activity)
{
    if (activity.DocumentId.HasValue) return activity.DocumentId;
    if (activity.TaxFilingId.HasValue) return activity.TaxFilingId;
    if (activity.PaymentId.HasValue) return activity.PaymentId;
    if (activity.MessageId.HasValue) return activity.MessageId;
    if (activity.ClientId.HasValue) return activity.ClientId;
    return null;
}

/// <summary>
/// Apply PII masking to export data if enabled
/// Phase 3: PII Masking (fixes_plan.md 2.4)
/// </summary>
private List<T> ApplyPiiMasking<T>(List<T> data, ExportRequestDto request) where T : class
{
    // Check if PII masking is enabled for this export
    if (!request.MaskPii)
        return data;

    try
    {
        var maskingOptions = new PiiMaskingOptions
        {
            Enabled = true,
            Level = MaskingLevel.Partial,
            ExcludedFields = request.PiiExcludedFields
        };

        // Convert to dictionaries for masking
        var jsonData = JsonSerializer.Serialize(data);
        var maskedJson = _piiMaskingService.MaskPiiInJson(jsonData, maskingOptions);
        
        // Deserialize back to typed objects
        var maskedData = JsonSerializer.Deserialize<List<T>>(maskedJson);
        
        _logger.LogInformation("Applied PII masking to {RecordCount} records", data.Count);
        
        return maskedData ?? data;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error applying PII masking, returning unmasked data");
        return data;
    }
}
}
}